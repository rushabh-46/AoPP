//
//Generated by JTB 1.3.2
//

package visitor;

import java.util.*;
import java.util.Map.Entry;
import syntaxtree.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirstSymbolTable<R, A> implements GJVisitor<R, A> {

  /**
   * map of all the class names and their ClassDetails
   * this gets set in Main itself. So no worries
   */
  public HashMap<String, ClassDetails> classDefinitions = null;

  // store the class fields and class methods separately

  /**
   *  global class fields
   *  mapping of class name and corresponding FieldTable
   */
  public HashMap<String, ClassFieldTable> globalClassFieldTable = null;

  /**
   *  global class methods
   *  This will also contain overriden methods added later
   *  mapping of class name all the methodTable.
   *  the methodTable itself will the insights, formals and other imp things
   *  What all to store ????????????????????????????????????
   */
  public HashMap<String, HashMap<String, ClassMethodTable>> globalClassMethodTable =
    null;

  /**
   * This Class - Symbol
   * This Class - SymbolTableEntry
   */
  //  private Symbol thisSymbol = null;
  //  private SymbolTableEntry thisSTE = null;

  /**
   *  private current class field table
   */
  private ClassFieldTable currentClassFieldTable = null;

  /**
   *  private current class method table
   */
  private ClassMethodTable currentClassMethodTable = null;

  /**
   *  private current method map
   */
  private HashMap<String, ClassMethodTable> currentClassMethodMap = null;

  /**
   * main method
   */
  public ClassMethodTable main = null;

  /**
   * private current class name
   */
  private String currentClassName = null;

  /**
   *  private type name
   *  Why ????????
   */
  private String varTypeName = null;

  /**
   * Label for each statement in the program
   */
  private int label = 1;

  /**
   * Just to keep track for left hand side identifier while saving statements
   * And it is enforced to NULL when the LHS is not a simple IDENTIFIER
   * This value is used in PrimaryExpression
   */
  private String lhsId = null;

  /**
   * Used to identify which primary expression
   * 1 -> integerLiteral, True, False
   * 2 -> Id, this
   * 5 -> simple alloc
   * 10 -> array alloc
   * -1 -> not expression
   * TRY TO REPLACE WITH ENUMS
   */
  private int whichPrimaryExp = 0;

  /**
   * Used to identify which expression
   * Note that only AssignmentStatement has Exp :
   *        Id = Exp
   * 100 -> MessageSend (PrimarExp.id(args))
   * 15 -> FieldRead
   * 20 -> PrimaryExp (only PrimaryExp)
   * TRY TO REPLACE WITH ENUMS
   */
  private int whichExp = 0;

  /**
   * This stores the id used in primary expression
   * Note that in all the primary expressions, exactly one identifier is used.
   */
  private String primaryExpId = null;

  /**
   * Stores the query Id
   */
  private int queryId = 0;

  /**
   * List of arguments
   */
  private ArrayList<String> arguments = new ArrayList<String>();

  /**
   * temporary locals created with names of the form {$*}
   * e.g. $, $$, $$$, $$$$, $$$$$
   */
  private String tempDollarLocal = "";

  /**
   * Used for nested while statements.
   * We may have to reanalyze the statements.
   */
  private int nestedWhileStatementStartIndex = 0;

  /**
   * List of all the query statements found in parsing order
   */
  public static final ArrayList<QueryStmnt> qStatements = new ArrayList<QueryStmnt>();

  public R visit(NodeList n, A argu) {
    R _ret = null;
    for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
      e.nextElement().accept(this, argu);
    }
    return _ret;
  }

  public R visit(NodeListOptional n, A argu) {
    if (n.present()) {
      R _ret = null;
      for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
        e.nextElement().accept(this, argu);
      }
      return _ret;
    } else return null;
  }

  public R visit(NodeOptional n, A argu) {
    if (n.present()) return n.node.accept(this, argu); else return null;
  }

  public R visit(NodeSequence n, A argu) {
    R _ret = null;
    for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
      e.nextElement().accept(this, argu);
    }
    return _ret;
  }

  public R visit(NodeToken n, A argu) {
    return null;
  }

  //
  // User-generated visitor methods below
  //

  /**
   * f0 -> MainClass()
   * f1 -> ( TypeDeclaration() )*
   * f2 -> <EOF>
   */
  public R visit(Goal n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> "class"
   * f1 -> Identifier()
   * f2 -> "{"
   * f3 -> "public"
   * f4 -> "static"
   * f5 -> "void"
   * f6 -> "main"
   * f7 -> "("
   * f8 -> "String"
   * f9 -> "["
   * f10 -> "]"
   * f11 -> Identifier()
   * f12 -> ")"
   * f13 -> "{"
   * f14 -> ( VarDeclaration() )*
   * f15 -> ( QStatement() )*
   * f16 -> "}"
   * f17 -> "}"
   */
  public R visit(MainClass n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu); // n.f1.f0.toString()

    // Main class name can be anything not necessariy 'Main'
    currentClassName = n.f1.f0.toString();
    ClassFieldTable fTable = new ClassFieldTable(n.f1.f0.toString());
    // no fields in this class
    // blank field table
    globalClassFieldTable.put(n.f1.f0.toString(), fTable);
    // this object - although not required in Main
    //    this.thisSymbol = new Symbol("this", currentClassName);
    //    this.thisSTE = new SymbolTableEntry("this", currentClassName);
    //    this.thisSTE.setAsParam();

    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);
    n.f5.accept(this, argu);
    n.f6.accept(this, argu);
    n.f7.accept(this, argu);
    n.f8.accept(this, argu);
    n.f9.accept(this, argu);
    n.f10.accept(this, argu);
    n.f11.accept(this, argu);
    n.f12.accept(this, argu);
    n.f13.accept(this, argu);

    ClassMethodTable mTable = new ClassMethodTable("main", currentClassName);
    this.main = mTable;
    currentClassMethodTable = mTable;
    //    mTable.table.put(this.thisSymbol, this.thisSTE);
    //    mTable.paramsSummary.add(this.thisSTE);

    n.f14.accept(this, argu);
    n.f15.accept(this, argu);
    n.f16.accept(this, argu);
    n.f17.accept(this, argu);

    HashMap<String, ClassMethodTable> mMap = new HashMap<String, ClassMethodTable>();
    mMap.put("main", mTable);
    globalClassMethodTable.put(n.f1.f0.toString(), mMap);
    currentClassMethodTable = null;

    return _ret;
  }

  /**
   * f0 -> ClassDeclaration()
   *       | ClassExtendsDeclaration()
   */
  public R visit(TypeDeclaration n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> "class"
   * f1 -> Identifier()
   * f2 -> "{"
   * f3 -> ( VarDeclaration() )*
   * f4 -> ( MethodDeclaration() )*
   * f5 -> "}"
   */
  public R visit(ClassDeclaration n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);

    currentClassName = n.f1.f0.toString();
    ClassFieldTable fTable = new ClassFieldTable(n.f1.f0.toString());
    currentClassFieldTable = fTable;

    n.f3.accept(this, argu);

    globalClassFieldTable.put(n.f1.f0.toString(), fTable);
    currentClassFieldTable = null;
    HashMap<String, ClassMethodTable> mMap = new HashMap<String, ClassMethodTable>();
    currentClassMethodMap = mMap;

    n.f4.accept(this, argu);

    globalClassMethodTable.put(n.f1.f0.toString(), mMap);
    currentClassMethodMap = null;

    n.f5.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> "class"
   * f1 -> Identifier()
   * f2 -> "extends"
   * f3 -> Identifier()
   * f4 -> "{"
   * f5 -> ( VarDeclaration() )*
   * f6 -> ( MethodDeclaration() )*
   * f7 -> "}"
   */
  public R visit(ClassExtendsDeclaration n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);

    currentClassName = n.f1.f0.toString();
    ClassFieldTable fTable = new ClassFieldTable(n.f1.f0.toString());
    currentClassFieldTable = fTable;

    n.f3.accept(this, argu);
    n.f4.accept(this, argu);
    n.f5.accept(this, argu);

    globalClassFieldTable.put(n.f1.f0.toString(), fTable);
    currentClassFieldTable = null;
    HashMap<String, ClassMethodTable> mMap = new HashMap<String, ClassMethodTable>();
    currentClassMethodMap = mMap;

    n.f6.accept(this, argu);

    globalClassMethodTable.put(n.f1.f0.toString(), mMap);
    currentClassMethodMap = null;

    n.f7.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Type()
   * f1 -> Identifier()
   * f2 -> ";"
   */
  public R visit(VarDeclaration n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    String typeName = varTypeName;

    n.f1.accept(this, argu);
    n.f2.accept(this, argu);

    if (currentClassMethodTable != null) {
      currentClassMethodTable.table.put(
        new Symbol(n.f1.f0.toString(), typeName),
        new SymbolTableEntry(n.f1.f0.toString(), typeName)
      );
    } else if (currentClassFieldTable != null) {
      currentClassFieldTable.table.put(
        new Symbol(n.f1.f0.toString(), typeName),
        new SymbolTableEntry(n.f1.f0.toString(), typeName)
      );
    } else {
      // System.out.println(
      //   "ERROR: Which var Declaration is this? id = " + n.f1.f0.toString()
      // );
    }
    label++;

    return _ret;
  }

  /**
   * f0 -> "public"
   * f1 -> Type()
   * f2 -> Identifier()
   * f3 -> "("
   * f4 -> ( FormalParameterList() )?
   * f5 -> ")"
   * f6 -> "{"
   * f7 -> ( VarDeclaration() )*
   * f8 -> ( QStatement() )*
   * f9 -> "return"
   * f10 -> Identifier()
   * f11 -> ";"
   * f12 -> "}"
   */
  public R visit(MethodDeclaration n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu); // method name

    ClassMethodTable mTable = new ClassMethodTable(
      n.f2.f0.toString(),
      currentClassName
    );
    currentClassMethodTable = mTable;
    // add the class fields by same reference (duplicating)
    // NO !! They will be called from symbol table .get()
    // and we will check scope of 'this'
    // addClassFieldsInMethod();

    n.f3.accept(this, argu);
    n.f4.accept(this, argu);
    n.f5.accept(this, argu);
    n.f6.accept(this, argu);
    n.f7.accept(this, argu);
    n.f8.accept(this, argu);
    n.f9.accept(this, argu);
    n.f10.accept(this, argu);
    n.f11.accept(this, argu);

    mTable.returnId = n.f10.f0.toString();
    // you should not create a new STE for return Id. It already exists. Just map it from the table.
    // mTable.returnSummary = new SymbolTableEntry(n.f10.f0.toString(), typeName);
    label++;

    n.f12.accept(this, argu);

    // Adding method table in class method map
    currentClassMethodMap.put(n.f2.f0.toString(), mTable);
    currentClassMethodTable = null;

    return _ret;
  }

  /**
   * f0 -> FormalParameter()
   * f1 -> ( FormalParameterRest() )*
   */
  public R visit(FormalParameterList n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Type()
   * f1 -> Identifier()
   */
  public R visit(FormalParameter n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    String typeName = varTypeName;
    n.f1.accept(this, argu);

    Symbol symbol = new Symbol(n.f1.f0.toString(), typeName);
    SymbolTableEntry ste = new SymbolTableEntry(n.f1.f0.toString(), typeName);
    ste.setAsParam();
    currentClassMethodTable.table.put(symbol, ste);
    currentClassMethodTable.paramsSummary.add(ste);

    return _ret;
  }

  /**
   * f0 -> ","
   * f1 -> FormalParameter()
   */
  public R visit(FormalParameterRest n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> ArrayType()
   *       | BooleanType()
   *       | IntegerType()
   *       | Identifier()
   */
  public R visit(Type n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> "int"
   * f1 -> "["
   * f2 -> "]"
   */
  public R visit(ArrayType n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    varTypeName = "int[]";
    return _ret;
  }

  /**
   * f0 -> "boolean"
   */
  public R visit(BooleanType n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    varTypeName = "Boolean";
    return _ret;
  }

  /**
   * f0 -> "int"
   */
  public R visit(IntegerType n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    varTypeName = "int";
    return _ret;
  }

  /**
   * f0 -> ( Query() )*
   * f1 -> Statement()
   */
  public R visit(QStatement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> <SCOMMENT1>
   * f1 -> Identifier()
   * f2 -> "alias?"
   * f3 -> Identifier()
   * f4 -> <SCOMMENT2>
   */
  public R visit(Query n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);

    ///////// Query Statement //////////
    this.queryId++;
    QueryStmnt queryStmnt = new QueryStmnt(this.queryId);
    // assign Ids
    queryStmnt.setId1(n.f1.f0.toString());
    queryStmnt.setId2(n.f3.f0.toString());
    // adding to statements
    currentClassMethodTable.statements.add(queryStmnt);
    GJDepthFirstSymbolTable.qStatements.add(queryStmnt);

    return _ret;
  }

  /**
   * f0 -> Block()
   *       | AssignmentStatement()
   *       | ArrayAssignmentStatement()
   *       | FieldAssignmentStatement()
   *       | IfStatement()
   *       | WhileStatement()
   *       | PrintStatement()
   */
  public R visit(Statement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> "{"
   * f1 -> ( QStatement() )*
   * f2 -> "}"
   */
  public R visit(Block n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "="
   * f2 -> Expression()
   * f3 -> ";"
   */
  public R visit(AssignmentStatement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    lhsId = n.f0.f0.toString();

    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);

    lhsId = null;
    label++;

    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "["
   * f2 -> Identifier()
   * f3 -> "]"
   * f4 -> "="
   * f5 -> Identifier()
   * f6 -> ";"
   */
  public R visit(ArrayAssignmentStatement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);
    n.f5.accept(this, argu);
    n.f6.accept(this, argu);

    label++;

    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "."
   * f2 -> Identifier()
   * f3 -> "="
   * f4 -> Identifier()
   * f5 -> ";"
   */
  public R visit(FieldAssignmentStatement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);
    n.f5.accept(this, argu);

    ///////// STORE Statement //////////
    StoreStmnt storeStmnt = new StoreStmnt(label);
    // assign RHS and LHS
    storeStmnt.setId1(n.f0.f0.toString());
    storeStmnt.setId2(n.f2.f0.toString());
    storeStmnt.setId3(n.f4.f0.toString());
    // adding to statements
    currentClassMethodTable.statements.add(storeStmnt);
    label++;

    return _ret;
  }

  /**
   * f0 -> "if"
   * f1 -> "("
   * f2 -> Identifier()
   * f3 -> ")"
   * f4 -> Statement()
   * f5 -> "else"
   * f6 -> Statement()
   */
  public R visit(IfStatement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);
    n.f5.accept(this, argu);
    n.f6.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> "while"
   * f1 -> "("
   * f2 -> Identifier()
   * f3 -> ")"
   * f4 -> Statement()
   */
  public R visit(WhileStatement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    int whileGetBack = this.nestedWhileStatementStartIndex;
    this.nestedWhileStatementStartIndex =
      this.currentClassMethodTable.statements.size();

    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);

    WhileEndStmnt wEstmnt = new WhileEndStmnt(label);
    // System.out.println(
    //   "While statement of nextIndex = " + this.nestedWhileStatementStartIndex
    // );
    wEstmnt.setStartStatementIndex(this.nestedWhileStatementStartIndex);
    currentClassMethodTable.statements.add(wEstmnt);
    this.nestedWhileStatementStartIndex = whileGetBack;

    return _ret;
  }

  /**
   * f0 -> "System.out.println"
   * f1 -> "("
   * f2 -> Identifier()
   * f3 -> ")"
   * f4 -> ";"
   */
  public R visit(PrintStatement n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);

    label++;

    return _ret;
  }

  /**
   * f0 -> AndExpression()
   *       | CompareExpression()
   *       | PlusExpression()
   *       | MinusExpression()
   *       | TimesExpression()
   *       | ArrayLookup()
   *       | ArrayLength()
   *       | MessageSend() -> 100 -> AllocStmnt + (this) methodCall |  (object)methodCall
   *       | FieldRead() -> 15 LoadStmnt
   *       | PrimaryExpression() -> 20 -> AllocStmnt | CopyStmnt
   */
  public R visit(Expression n, A argu) {
    R _ret = null;
    this.whichExp = 0;
    n.f0.accept(this, argu);

    AllocStmnt allocStmnt;
    // Here you can better understand whether it was MessageSend or just PrimaryExpression.
    if (this.whichExp == 20) {
      switch (this.whichPrimaryExp) {
        case 2: // = Id | this
          /////// COPY STATEMENT ////////
          CopyStmnt copyStmnt = new CopyStmnt(label);
          /////////////////////// assign RHS and LHS
          copyStmnt.setId1(this.lhsId);
          copyStmnt.setId2(this.primaryExpId);
          // System.out.println("<PrimaryExpId> in Copy = " + this.primaryExpId);
          currentClassMethodTable.statements.add(copyStmnt);
          break;
        case 5:
        case 10: // = new Id()
          ///////// ALLOC STATEMENT ////////
          allocStmnt = new AllocStmnt(label);
          /////////////////// assign LHS and RHS
          allocStmnt.setId1(this.lhsId);
          allocStmnt.setId2(this.primaryExpId);
          // System.out.println("<PrimaryExpId> in Alloc = " + this.primaryExpId);
          currentClassMethodTable.statements.add(allocStmnt);
          break;
        case 1:
        case -1: // = true | false | <Int> | !<Id>
          ///////// ALLOC STATEMENT ////////
          allocStmnt = new AllocStmnt(label);
          /////////////////// assign LHS and RHS
          allocStmnt.setId1(this.lhsId);
          allocStmnt.setId2(this.primaryExpId);
          currentClassMethodTable.statements.add(allocStmnt);
      }
    } else if (this.whichExp == 0) {
      // All other expressions considered like creating a new object
      // System.out.println("Simple expressions : defaulted to Alloc! label=" + label);
      ///////// ALLOC STATEMENT ////////////
      allocStmnt = new AllocStmnt(label);
      /////////////////// assign LHS and RHS ////////////
      allocStmnt.setId1(this.lhsId);
      currentClassMethodTable.statements.add(allocStmnt);
    }
    //    switch (this.whichExp) {
    //      case 20: // Just <PrimaryExp>
    //        if (this.whichPrimaryExp == 2) {
    //          // = Id | this
    //          /////// COPY STATEMENT ////////
    //          CopyStmnt copyStmnt = new CopyStmnt(label);
    //          /////////////////////// assign RHS and LHS
    //          copyStmnt.setId1(this.lhsId);
    //          copyStmnt.setId2(this.primaryExpId);
    //          // System.out.println("<PrimaryExpId> in Copy = " + this.primaryExpId);
    //          currentClassMethodTable.statements.add(copyStmnt);
    //        } else if (this.whichPrimaryExp == 5 || this.whichPrimaryExp == 10) {
    //          // = new Id()
    //          ///////// ALLOC STATEMENT ////////
    //          AllocStmnt allocStmnt = new AllocStmnt(label);
    //          /////////////////// assign LHS and RHS
    //          allocStmnt.setId1(this.lhsId);
    //          allocStmnt.setId2(this.primaryExpId);
    //          // System.out.println("<PrimaryExpId> in Alloc = " + this.primaryExpId);
    //          currentClassMethodTable.statements.add(allocStmnt);
    //        } else if (this.whichPrimaryExp == 1 || this.whichPrimaryExp == -1) {
    //          // = true | false | <Int> | !<Id>
    //          ///////// ALLOC STATEMENT ////////
    //          AllocStmnt allocStmnt = new AllocStmnt(label);
    //          /////////////////// assign LHS and RHS
    //          allocStmnt.setId1(this.lhsId);
    //          allocStmnt.setId2(this.primaryExpId);
    //          currentClassMethodTable.statements.add(allocStmnt);
    //        }
    //        break;
    //      case 0: // All other expressions considered like creating a new object
    //        // System.out.println("Simple expressions : defaulted to Alloc! label=" + label);
    //        ///////// ALLOC STATEMENT ////////
    //        AllocStmnt allocStmnt = new AllocStmnt(label);
    //        /////////////////// assign LHS and RHS
    //        allocStmnt.setId1(this.lhsId);
    //        currentClassMethodTable.statements.add(allocStmnt);
    //        break;
    //    }

    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "&&"
   * f2 -> Identifier()
   */
  public R visit(AndExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "<"
   * f2 -> Identifier()
   */
  public R visit(CompareExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "+"
   * f2 -> Identifier()
   */
  public R visit(PlusExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "-"
   * f2 -> Identifier()
   */
  public R visit(MinusExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "*"
   * f2 -> Identifier()
   */
  public R visit(TimesExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "["
   * f2 -> Identifier()
   * f3 -> "]"
   */
  public R visit(ArrayLookup n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "."
   * f2 -> "length"
   */
  public R visit(ArrayLength n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> "."
   * f2 -> Identifier()
   */
  public R visit(FieldRead n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);

    /////// LOAD Statement ///////
    LoadStmnt loadStmnt = new LoadStmnt(label);
    // assign RHS's and LHS
    loadStmnt.setId1(lhsId);
    loadStmnt.setId2(n.f0.f0.toString());
    loadStmnt.setId3(n.f2.f0.toString());
    // add to statements
    currentClassMethodTable.statements.add(loadStmnt);

    this.whichExp = 15;

    return _ret;
  }

  /**
   * f0 -> PrimaryExpression() -> can be AllocationE, Identifier, This
   * f1 -> "."
   * f2 -> Identifier()
   * f3 -> "("
   * f4 -> ( ArgList() )?
   * f5 -> ")"
   */
  public R visit(MessageSend n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);

    String primaryId = varTypeName;
    int primExpression = this.whichPrimaryExp;

    n.f2.accept(this, argu);

    this.arguments.clear();
    String methodName = n.f2.f0.toString();

    n.f3.accept(this, argu);
    n.f4.accept(this, argu);
    n.f5.accept(this, argu);

    // System.out.println(
    //   "MessageSend expression. primary expression = " + primExpression
    // );

    if (primExpression == -1 || primExpression == 2) {
      // <Id>.func(argList)
      /////// BasicCall Statement ///////
      BasicCallStmnt callStmnt = new BasicCallStmnt(label);
      callStmnt.setId1(lhsId);
      callStmnt.setId2(primaryId);
      callStmnt.setId3(methodName);
      callStmnt.setActuals(this.arguments);
      callStmnt.global = globalClassMethodTable;
      callStmnt.mTable = currentClassMethodTable;
      // first find type and then do bottomToTop to generate callee's
      String typeName = currentClassMethodTable.search(
        primaryId,
        methodName,
        classDefinitions
      );
      if (typeName != null) {
        ArrayList<String> calleeClasses = classDefinitions
          .get(typeName)
          .subToSuper(methodName);
        callStmnt.addCallees(calleeClasses);
        // add to statements
        currentClassMethodTable.statements.add(callStmnt);
        // small hack to avoid x = ...f(x) types -> add again
        currentClassMethodTable.statements.add(callStmnt);
      } else {
        // System.out.println("!!!!!!!!! FAILED to find the calling type !!!!!!!!");
      }
    } else if (primExpression == 5 || primExpression == 10) {
      // new <Id> ().func(argList)  OR   new int [<Id>].func(argList) (not possible)
      // 1. Create a local variable - tempDollarLocal of type primayryId
      // 2. Alloc it - <AllocStatement>
      // 3. Call on it !!
      // System.out.println("Working on alloc+call statement !!");
      this.tempDollarLocal = this.tempDollarLocal + "$";
      currentClassMethodTable.table.put(
        new Symbol(this.tempDollarLocal, primaryId),
        new SymbolTableEntry(this.tempDollarLocal, primaryId)
      );

      ///////// ALLOC STATEMENT ////////
      AllocStmnt allocStmnt = new AllocStmnt(label);
      /////////////////// assign LHS and RHS
      allocStmnt.setId1(this.tempDollarLocal);
      currentClassMethodTable.statements.add(allocStmnt);

      /////// BasicCall Statement ///////
      BasicCallStmnt callStmnt = new BasicCallStmnt(label);
      callStmnt.setId1(lhsId);
      callStmnt.setId2(this.tempDollarLocal);
      callStmnt.setId3(methodName);
      callStmnt.setActuals(this.arguments);
      callStmnt.global = globalClassMethodTable;
      callStmnt.mTable = currentClassMethodTable;
      // first find type and then do bottomToTop to generate callee's
      String typeName = primaryId;
      ArrayList<String> calleeClasses = classDefinitions
        .get(typeName)
        .subToSuper(methodName);
      callStmnt.addCallees(calleeClasses);
      // add to statements
      currentClassMethodTable.statements.add(callStmnt);
      // small hack to avoid x = ...f(x) types -> add again
      currentClassMethodTable.statements.add(callStmnt);
    } else {
      // System.out.println("Program semantics incorrect !!");
    }

    // All function call statements, create them here.
    // new A().m() -> actuals will be null, no change in formals or actuals

    this.whichExp = 100;

    return _ret;
  }

  /**
   * f0 -> Identifier()
   * f1 -> ( ArgRest() )*
   */
  public R visit(ArgList n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    this.arguments.add(n.f0.f0.toString());

    n.f1.accept(this, argu);
    return _ret;
  }

  /**
   * f0 -> ","
   * f1 -> Identifier()
   */
  public R visit(ArgRest n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);

    this.arguments.add(n.f1.f0.toString());

    return _ret;
  }

  /**
   * f0 -> IntegerLiteral() -> 1
   *       | TrueLiteral() -> 1
   *       | FalseLiteral() -> 1
   *       | Identifier() -> 2
   *       | ThisExpression() -> 2
   *       | ArrayAllocationExpression() -> 10
   *       | AllocationExpression() -> 5
   *       | NotExpression() -> -1
   */
  public R visit(PrimaryExpression n, A argu) {
    R _ret = null;

    this.whichPrimaryExp = 0;

    n.f0.accept(this, argu);

    // Note that in all the primary expressions, exactly one identifier is used.
    this.primaryExpId = this.varTypeName;
    this.whichExp = 20;

    return _ret;
  }

  /**
   * f0 -> <INTEGER_LITERAL>
   */
  public R visit(IntegerLiteral n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    this.whichPrimaryExp = 1;

    return _ret;
  }

  /**
   * f0 -> "true"
   */
  public R visit(TrueLiteral n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    this.whichPrimaryExp = 1;

    return _ret;
  }

  /**
   * f0 -> "false"
   */
  public R visit(FalseLiteral n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    this.whichPrimaryExp = 1;

    return _ret;
  }

  /**
   * f0 -> <IDENTIFIER>
   */
  public R visit(Identifier n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    this.varTypeName = n.f0.toString();
    this.whichPrimaryExp = 2;

    return _ret;
  }

  /**
   * f0 -> "this"
   */
  public R visit(ThisExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);

    this.varTypeName = "this";
    this.whichPrimaryExp = 2;

    return _ret;
  }

  /**
   * f0 -> "new"
   * f1 -> "int"
   * f2 -> "["
   * f3 -> Identifier()
   * f4 -> "]"
   */
  public R visit(ArrayAllocationExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);
    n.f4.accept(this, argu);

    this.whichPrimaryExp = 10;

    return _ret;
  }

  /**
   * f0 -> "new"
   * f1 -> Identifier()
   * f2 -> "("
   * f3 -> ")"
   */
  public R visit(AllocationExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);
    n.f2.accept(this, argu);
    n.f3.accept(this, argu);

    this.whichPrimaryExp = 5;

    return _ret;
  }

  /**
   * f0 -> "!"
   * f1 -> Identifier()
   */
  public R visit(NotExpression n, A argu) {
    R _ret = null;
    n.f0.accept(this, argu);
    n.f1.accept(this, argu);

    // USELESS expression doesn't contribute in analysis mostly
    // because not a valid statement imo
    this.whichPrimaryExp = -1;

    return _ret;
  }

  /**
   * Helper print method
   * Used for debugging
   */
  public void print() {
    for (Entry<String, ClassFieldTable> fMap : globalClassFieldTable.entrySet()) {
      fMap.getValue().print();
      System.out.println();
    }

    for (Entry<String, HashMap<String, ClassMethodTable>> mMap : globalClassMethodTable.entrySet()) {
      System.out.println("Class method details for " + mMap.getKey());
      for (Entry<String, ClassMethodTable> mTable : mMap
        .getValue()
        .entrySet()) {
        System.out.println("Method details for " + mTable.getKey() + ":");
        mTable.getValue().print();
        System.out.println();
      }
      System.out.println();
    }
  }
}
